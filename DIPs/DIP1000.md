# Scoped Pointers

| Section         | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1000                                                            |
| RC#             | 2                                                |
| Author:         | Marc Sch√ºtz, deadalnix, Andrei Alexandrescu, Walter Bright      |
| Implementation: |                                                                 |
| Status:         | Draft                                                           |

## Abstract

## Rationale

Consider the following blatant programmer error:

```d
int* fun()
{
	int a;
	return &a;
}
```

So blatant it is, in fact, that the current D compiler (and also some C and C++ compilers using the appropriate flags) detect the pattern and reject it during compilation. And they are right to do so---save for special code that needs to introspect the stack, this code could never be correct.

The detection is easy to fool. The following code passes the D compiler, even though it is as incorrect as the previous one:

```d
int* fun()
{
	int a;
	auto p = &a;
	return p;
}
```

The reason for this code being allowed is a combination of limited compiler technology and the difficulty to eliminate only incorrect cases without also rejecting valid programs. (This is a perennial tension in semantic checking of code.) Usually, unsafe uses arise from using together artifacts that in isolation have no obvious safety issues. Consider for example:

```d
int[] fun(int[] a)
{
    int[1] b = [ 0 ];
    if (a is null) a = b;
    import std.algorithm;
    return a.find(0);
}
```

Each of the language elements used in the function above (statically-sized arrays, assigning a safe array to a slice, the `find` algorithm) can be used safely. However, the resulting code is unsafe because `fun` may return a pointer to the stack-allocated contents of `b`. Colloquially, a pointer to private stack data (or more generally some piece of data with limited validity) "escapes" the function (or more generally the context in which it is valid).

Escaping is not limited to stack-allocated data. Consider an array that manages its own data by means of eagerly copying its payload in the copy constructor and deallocating it in the destructor. Such an array might expose references to the managed data by means of `opIndex`.

```d
struct EagerArray(T)
{
    private T[] payload;
    ...
    ref T opIndex(size_t n) { return payload[n]; }
}
```

Even though it seems such an array provides no escaping means for its data, it is still exposed. For example:

```d
void fun(ref EagerArray!int a, ref int x)
{
    a = EagerArray!int(10000); // possibly reallocate the array
    x = 42; // possibly unsafe!
}
void main()
{
    auto a = EagerArray!int(1);
    fun(a, a[0]);
}
```

This code is unsafe because there is no accounting for the fact that live references exist into the contents of the array, which presumably resizing the array will render invalid.

A more sophisticated approach is needed to reject all unsafe cases and allow most safe cases. The related method is called [escape analysis](https://en.wikipedia.org/wiki/Escape_analysis) and can be used for either optimizing code or (in this case) determining whether it is safe.

This DIP proposes an escape analysis for D, which, in conjunction with the use of the `scope` keyword, guarantees that `@safe` code cannot escape pointers.

## Related work

## The `scope` attribute

The `scope` attribute may be attached to (a) function parameters, (b) local variables.

### `scope` Function Parameters

When used with a pointer or array function parameter, `scope` means the function will never keep that pointer or array beyond its execution. For the purposes of the analysis:

* `struct` objects passed by value are analyzed the same as each field passed into the function by value
* `struct` object passed by `ref` are analyzed the sane as each field passed by `ref`
* built-in arrays count as `struct`s with a pointer value and a length value
* `class` references count as pointers to `struct`s containing their respective fields

So in the following we focus on primitive types and pointers to `struct`s. The rules governing `scope` parameters are the following:

1. For all non-pointer types passed by value, `scope` is ignored. It is not considered part of the function type. Example:

```d
void fun(scope int x);
static assert(is(typeof(&fun) == void function(int)));
```
